(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const {print, log, open, read} = wlibc

log("WebContainer::Init")

__GLOBAL__.window = {}

const {TextEncoder, TextDecoder} = require('text-encoding-shim')
const hexdump = require('hexdump-js')

const Utf8ArrayToStr = require('./src/Utf8ArrayToStr')

const memory = new WebAssembly.Memory({initial: 2})
const buffer = new Uint8Array(memory.buffer)

const STACK_BEGIN = 10000

// The stack/heap seaparator exists here.
// The stack grows downwards to zero.
// The heap grows upward to te page break.
buffer[1] = STACK_BEGIN

// Allocate free space on the heap.
let malloc_offset = STACK_BEGIN + 1
function malloc(s) {
    const next = malloc_offset
    malloc_offset = malloc_offset + s
    return next
}
const __NR_openat = 56
const __NR_read = 63
const __NR_close = 57

function nullTerminatedString(i) {
    let s = ""
    while(buffer[i] !== 0) {
        s += String.fromCharCode(buffer[i])
        i++
    }
    return s
}

const imports = {
    env: {
        memory,
        close: (fd) => {
            return wlibc.close(fd)
        },
        read: (fd, ptr, len) => {
            const buf = wlibc.read(fd, len)
            const bufa = new Uint8Array(buf)
            
            for(let i=0; i < bufa.length; i++) {
                buffer[ptr + i] = bufa[i]
            }

            return bufa.length
        },
        open: (pathPtr) => {
            let s = ""
            let i = pathPtr
            while(buffer[i] !== 0) {
                s += String.fromCharCode(buffer[i])
                i++
            }
            return wlibc.open(s)
        },
        print: (arg) => {
            let s = ""
            let i = arg
            while(buffer[i]) {
                s += String.fromCharCode(buffer[i])
                i++
            }
            wlibc.print(s)
        },
        __syscall: (syscallno, argsPointer) => {
            const args = new Int32Array(buffer.slice(argsPointer, argsPointer + 4 * 7).buffer)
            switch (syscallno) {
                case __NR_openat: {
                    const relfd = args[0] // "relative" fd to openat
                    const filenamePtr = args[1]
                    const filename = nullTerminatedString(filenamePtr)
                    const flags = args[2]
                    const mode = args[3]
                    const fd = wlibc.open(filename)
                    return fd
                }; break;
                case __NR_read: {
                    const [fd, ptr, count] = args
                    const data = wlibc.read(fd, count)
                    const bufa = new Uint8Array(data)
                    
                    for(let i=0; i < bufa.length; i++) {
                        buffer[ptr + i] = bufa[i]
                    }
                    return bufa.length;
                }; break;
                case __NR_close: {
                    const [fd] = args
                    return wlibc.close(fd)
                }; break;
                default: {
                    print(`Don't know how to implement ${syscallno} with args ${args}`)
                    return -1
                }; break;
            }
        },
        __syscall0: () => {
            print("syscall0")
        },
        __syscall1: () => {
            print("syscall1")
        },
        __syscall2: () => {
            print("syscall2")
        },
        __syscall3: () => {
            print("syscall3")
        },
        __syscall4: () => {
            print("syscall4")
        },
        __syscall5: () => {},
        __syscall6: () => {},
        __syscall7: () => {},
        __syscall8: () => {},
        __syscall9: () => {},
        a_ll: () => {},
        a_sc: () => {},
        a_barrier: () => {},
        a_cas: () => {},
        a_ll_p: () => {},
        a_sc_p: () => {},
        a_cas_p: () => {},
        a_ctz_64: () => {},
        a_clz_64: () => {},
        __netf2: () => {},
        __multf3: () => {},
        __extenddftf2: () => {},
        __trunctfsf2: () => {},
        __trunctfdf2: () => {},
        __subtf3: () => {},
        __unordtf2: () => {},
        __addtf3: () => {},
        __netf2: () => {},
        __multf3: () => {},
        __fixtfsi: () => {},
        __floatsitf: () => {},
        __fixunstfsi: () => {},
        __floatunsitf: () => {},
        malloc,
        _start() {},
    },
}

// Setup `main(int argc, char ** argv)`
// We have to write all the argv arguments to the head with our custom malloc.
// There is a lot of ArrayBuffer magic.
const argv = ["wasm", ...(__WASMARGS__.split(/\s+/))]
const argc = argv.length
const argvPointers = new Uint32Array(new ArrayBuffer(argv.length * 4))
var i = 0
for(const arg of argv) {
    const te = new TextEncoder()
    const be = te.encode(arg)
    const pt = malloc(be.byteLength + 1)
    
    // place each string on the heap
    buffer.set(be, pt)
    
    // record the pointer to another buffer
    // we will place this on the heap later
    argvPointers[i++] = pt
}
const st = malloc(argvPointers.byteLength)
// Need to recast our 32-bit pointer buffer to 8-bit typed array
// If we don't match the typed array sizes, weird stuff happens.
// If we cast them both to 32-bit arrays, the *st* pointer will be wrong.
buffer.set(new Uint8Array(argvPointers.buffer), st)


// Run WASM bundle
const o = WebAssembly
.instantiate(__WASMBUNDLE__, imports)
.then(r => {
    log("WebContainer::Begin")
    const exit = r.instance.exports.main(argc, st)
    log("WebContainer::Exit Code(" + exit + ")")
    return exit
})
.catch(e => {
    log(e.message)
    wlibc.exit(1)
})
.then(code => wlibc.exit(code||0))

},{"./src/Utf8ArrayToStr":4,"hexdump-js":2,"text-encoding-shim":3}],2:[function(require,module,exports){
(function () {
    var _fillUp = function (value, count, fillWith) {
            var l = count - value.length;
            var ret = "";
            while (--l > -1)
                ret += fillWith;
            return ret + value;
        },
        hexdump = function (arrayBuffer, offset, length) {

            var view = new DataView(arrayBuffer);
            offset = offset || 0;
            length = length || arrayBuffer.byteLength;

            var out = _fillUp("Offset", 8, " ") + "  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n";
            var row = "";
            for (var i = 0; i < length; i += 16) {
                row += _fillUp(offset.toString(16).toUpperCase(), 8, "0") + "  ";
                var n = Math.min(16, length - offset);
                var string = "";
                for (var j = 0; j < 16; ++j) {
                    if (j < n) {
                        var value = view.getUint8(offset);
                        string += value >= 32 ? String.fromCharCode(value) : ".";
                        row += _fillUp(value.toString(16).toUpperCase(), 2, "0") + " ";
                        offset++;
                    }
                    else {
                        row += "   ";
                        string += " ";
                    }
                }
                row += " " + string + "\n";
            }
            out += row;
            return out;
        };

    module.exports = hexdump;
})();

},{}],3:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
		var textEncoding = factory();
        root.TextEncoder = textEncoding.TextEncoder;
		root.TextDecoder = textEncoding.TextDecoder;
    }
}(this, function () {
	"use strict";
	// return native implementation if available
	var g = typeof GLOBAL !== 'undefined' ? GLOBAL : window;
	if (typeof g.TextEncoder !== 'undefined' && typeof g.TextDecoder !== 'undefined') {
		return {'TextEncoder': g.TextEncoder, 'TextDecoder': g.TextDecoder};
	}

	// allowed encoding strings for utf-8
	var utf8Encodings = [
		'utf8',
		'utf-8',
		'unicode-1-1-utf-8'
	];

	var TextEncoder = function(encoding) {
		if (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding != null) {
			throw new RangeError('Invalid encoding type. Only utf-8 is supported');
		} else {
			this.encoding = 'utf-8';
			this.encode = function(str) {
				if (typeof str !== 'string') {
					throw new TypeError('passed argument must be of tye string');
				}
				var binstr = unescape(encodeURIComponent(str)),
					arr = new Uint8Array(binstr.length);
				binstr.split('').forEach(function(char, i) {
					arr[i] = char.charCodeAt(0);
				});
				return arr;
			};
		}
	}

	var TextDecoder = function(encoding, options) {
		if (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding != null) {
			throw new RangeError('Invalid encoding type. Only utf-8 is supported');
		}
		else {
			this.encoding = 'utf-8';
			this.ignoreBOM = false;
			this.fatal = (typeof options !== 'undefined' && fatal in options) ? options.fatal : false;
			if (typeof this.fatal !== 'boolean') {
				throw new TypeError('fatal flag must be boolean');
			}
			this.decode = function (view, options) {
				if (typeof view === 'undefined') {
					return '';
				}

				var stream = (typeof options !== 'undefined' && stream in options) ? options.stream : false;
				if (typeof stream !== 'boolean') {
					throw new TypeError('stream option must be boolean');
				}

				if (!ArrayBuffer.isView(view)) {
					throw new TypeError('passed argument must be an array buffer view');
				} else {
					var arr = new Uint8Array(view.buffer),
						charArr = new Array(arr.length);
					arr.forEach(function(charcode, i) {
						charArr[i] = String.fromCharCode(charcode);
					});
					return decodeURIComponent(escape(charArr.join('')));
				}
			}
		}
	}
	return {'TextEncoder': TextEncoder, 'TextDecoder': TextDecoder};
}));
},{}],4:[function(require,module,exports){
module.exports = function Utf8ArrayToStr(array) {
    var out, i, len, c;
    var char2, char3;

    out = "";
    len = array.length;
    i = 0;
    while (i < len) {
        c = array[i++];
        switch (c >> 4) {
            case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
                // 0xxxxxxx
                out += String.fromCharCode(c);
                break;
            case 12: case 13:
                // 110x xxxx   10xx xxxx
                char2 = array[i++];
                out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
                break;
            case 14:
                // 1110 xxxx  10xx xxxx  10xx xxxx
                char2 = array[i++];
                char3 = array[i++];
                out += String.fromCharCode(((c & 0x0F) << 12) |
                    ((char2 & 0x3F) << 6) |
                    ((char3 & 0x3F) << 0));
                break;
        }
    }
    return out;
}
},{}]},{},[1]);
